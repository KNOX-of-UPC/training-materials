# 类与面向对象、原型与原型链

## 类的定义  

### 1. 创建对象  

```javascript
var calculator1 {
    name : 'calculate1',
    add : function(a,b){
        return a+b;
    }
}
```

### 2. 工厂方式

```javascript
function Calculator(name) {
        // 1. 创建对象
        var obj = new Object();

        // 2. 挂载属性
        obj.name = name;
        obj.add = function(a,b){
            return a+b;
        };

        return obj;
    }
var calculator1 = Calculator('calculator1');
```

### 3. 改进（构造函数）

```javascript
function Calculator(name){
    this.name = name;
    this.add = function(a,b){
        return a+b;
    }
}
var calculator1 = new Calculator('calculator1');
```

另一种写法

```javascript
class Calculator {
  constructor(name) {
      this.name = name;
  }
  add(a,b){
      return a+b;
  }
}

var calculator1 = new Calculator('calculator1');
```

* JavaScript 的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。
* JavaScript 使用构造函数（constructor）作为对象的模板。
* 函数体内部使用了this关键字，代表了所要生成的对象实例。

---

## 原型与原型链

### 1. 原型对象 prototype

```javascript
function Calculator(name){
    this.name = name;
    this.add = function(a,b){
        return a+b;
    }
}

calculator1 = new Calculator('1')
Calculator.prototype.nickNane='one';
console.log(calculator1.nickNane);
```

* 原型对象的所有属性和方法，都能被实例对象共享。
* 通过prototype可为类添加公共的属性和方法。
* prototype是函数对象特有的方法。

### 3. 类的继承

#### （1） call方法

```javascript
function Calculator(name){
    this.name = name;
    this.add = function(a,b){
        return a+b;
    }
}

function Computer(){
    Calculator.call(this,'computor');
    this.program = 'hello world';
}

dell = new Computer();
console.log(dell);
```

#### （2）原型链

```javascript
function Calculator(name){
    this.name = name;
    this.add = function(a,b){
        return a+b;
    }
}

function Computer(){
    this.program = 'hello world';
}
Computer.prototype = new Calculator('computer');

dell = new Computer();
console.log(dell);
console.log(dell.name);
```

* 使用call方法继承时__proto__指向Object，相当于将原型对象的属性方法添加到当前对象本身（意味着需要新的内存）。
* 使用原型链继承时__proto__指向为父对象。
* __proto__指向它的构造函数的prototype指向的对象。

```javascript
function Calculator(name){
    this.name = name;
    this.add = function(a,b){
        return a+b;
    }
}

function Computer(name){
    this.program = 'hello world';
    this.name = name;
}

function Robot(name){
    this.run = '10km/h';
    this.name = name;
}

Computer.prototype = new Calculator('calculator');
Robot.prototype = new Computer('computer');
var robot = new Robot('robot');
console.log(robot);
```

* 当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的__proto__属性(也就是它的构造函数的’prototype’属性)中去寻找。
* 处于原型链上的方法属性都可以被调用。

---

## 面向对象

### 1. 举例 计算1+2

面向过程：

```javascript
var a = 1;
var b = 2;
var result = a+b;
console.log(result);
```

面向对象

```javascript
var calculator = {
    'name' = 'calculator1',
    'add' = function(a,b){
        return a+b;
    }
var a = 1;
var b = 2;
var result = calculator.add(a,b);
console.log(result);
}
```

### 2. 面向对象编程练习——贪吃蛇

这里封装map、snake、food三个对象。

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>贪吃蛇</title>
</head>
<body>
    <canvas id="map" width="400" height="400" style="background:Black"></canvas>
    <h1>Score:</h1>
    <h2 id="score">0</h2>

    <script>
        //地图
        function Map() {
            this.field = document.getElementById("map").getContext("2d"); //画布
            this.draw = function (something) { //画蛇或者食物
                this.field.fillStyle = something.color;
                var position;
                for (position in something.positions) {
                    this.field.fillRect(something.positions[position][0], something.positions[position][1], 20, 20);
                }
            }
             this.clear = function () { //清除画布
                this.field.clearRect(0, 0, 400, 400);
            }
            this.judge = function (snake, food) { //判断状态（得分、失败、普通）
                var snakeHeadX = snake.positions[0][0];
                var snakeHeadY = snake.positions[0][1];
                var foodX = food.positions[0][0];
                var foodY = food.positions[0][1];
                if ((snakeHeadX == foodX) && (snakeHeadY == foodY)) {  //吃食物
                    snake.positions.unshift([foodX, foodY]);
                    food.positions[0] = [Math.floor(Math.random() * 20) * 20, Math.floor(Math.random() * 20) * 20];
                    this.clear();
                    this.draw(food);
                    this.draw(snake);
                    var score = document.getElementById('score');
                        score.innerHTML = (Number(score.innerHTML)+1).toString();
                }
                else if ((snakeHeadX+20 > 400) || (snakeHeadX < 0) || (snakeHeadY+20 > 400) || (snakeHeadY < 0)) {
                    alert('GIME OVER!'); //撞墙
                }
                else {
                    this.clear();
                    this.draw(food);
                    this.draw(snake);
                }
            }
        }
        
        //蛇
        function Snake() {
            this.positions = [[40 + 20, 40], [40, 40], [40 - 20, 40]]; //蛇的躯干
            this.color = "Yellow";
            this.direction = [1,0]; //蛇头方向
            this.move = function () { //移动
                this.positions.unshift([this.positions[0][0] + this.direction[0] * 20, this.positions[0][1] + this.direction[1] * 20]);
                this.positions.pop();
            }
            this.obeyOrders = function (snake = this) { //等待键盘上下左右
                document.onkeydown = function (event) {
                    var e = event || window.event || arguments.callee.caller.arguments[0];
                    var order = e.keyCode;
                    console.log(snake.direction);
                    switch (order) {
                        case 37:
                            snake.direction[0] = -1;
                            snake.direction[1] = 0;
                            break;
                        case 38:
                            snake.direction[1] = -1;
                            snake.direction[0] = 0;
                            break;
                        case 39:
                            snake.direction[0] = 1;
                            snake.direction[1] = 0;
                            break;
                        case 40:
                            snake.direction[1] = 1;
                            snake.direction[0] = 0;
                            break;
                        default:
                            ;
                    }
                };
            }
        }

        //食物
        function Food() {
            this.positions = [[Math.floor(Math.random() * 20) * 20, Math.floor(Math.random() * 20) * 20]]; //随机位置
            this.color = 'Red';
        }


        //开始执行
        (function () {

            var map = new Map();
            var snake = new Snake();
            var food = new Food();
            map.draw(snake);
            map.draw(food);
            snake.obeyOrders();
            var interval = setInterval(function () { //每0.5s走一步
                map.judge(snake, food);
                snake.move();
            }, 500);
        })()
    </script>


</body>

</html>
```

---
以上即为本文全部内容，若有其他技术问题或建议见解，欢迎qq、当面交流学习。  
作者 [@CYS](https://blog.csdn.net/CYS_zxcvbnm)  
2020年8月15日
